import { Markdown, Meta } from '@storybook/blocks';
import BackendCode from './todo-app-example/code.ts?raw';
import TypesCode from './todo-app-example/types.ts?raw';
import UiCode from './todo-app-example/ui.ts?raw';

<Meta title="Example" />

# Building a Todo App with Message Bus

This example demonstrates a complete Figma plugin using the Message Bus. We'll build a todo list manager that:
- Stores todos in memory (with automatic Map serialization)
- Handles errors gracefully
- Keeps UI in sync with plugin state

## Understanding the Architecture

> **Note**: This example demonstrates best practices for building maintainable Figma plugins.
> Each section includes explanations of important patterns and considerations.

The plugin follows a simple but effective architecture:

1. **UI Layer**: Sends commands and listens for events
2. **Plugin Layer**: Handles commands and manages state
3. **Message Bus**: Handles communication between layers

## 1. Type Definitions

First, let's define our message types:

<Markdown>
{`~~~typescript
${TypesCode}
~~~`}
</Markdown>

Key points about the types:
- Each todo has a unique ID (generated by the plugin)
- Commands represent all possible actions
- Events include both success and error cases
- Error events include the command that failed

## 2. Plugin Implementation

The plugin code manages todos and handles commands:

<Markdown>
{`~~~typescript
${BackendCode}
~~~`}
</Markdown>

Important implementation details:

1. **State Management**
   ```typescript
   const todos = new Map<string, Todo>();
   ```
   - Uses `Map` for O(1) lookups
   - Message Bus [automatically handles Map serialization](/?path=/docs/üì¶-message-bus-„Ä∞Ô∏è-üöß-beta-internals--docs#map-and-set-support):
     ```typescript
     // In plugin code
     todos.set('123', { text: 'Hello' });
     messageBus.publishEvent('TodoAdded', todos.get('123'));
     
     // Automatically serialized as:
     {
       dataType: 'Map',
       value: [['123', { text: 'Hello' }]]
     }
     
     // Automatically deserialized in UI
     messageBus.listenToEvent('TodoAdded', (todo) => {
       // todo is back to its original form
     });
     ```

2. **Error Handling**
   ```typescript
   try {
     // ... operation ...
     messageBus.publishEvent('TodoAdded', todo);
   } catch (error) {
     messageBus.publishEvent('TodoError', {
       message: error.message,
       command: 'AddTodo'
     });
   }
   ```
   - Every operation is wrapped in try/catch
   - Errors are communicated via events
   - UI can show appropriate error messages

## 3. UI Implementation

The UI code sends commands and stays in sync via events:

<Markdown>
{`~~~typescript
${UiCode}
~~~`}
</Markdown>

Notable patterns:

1. **State Syncing**
   ```typescript
   messageBus.listenToEvent('TodoAdded', (todo) => {
     todos.push(todo);
     renderTodos();
   });
   ```
   - Local state mirrors plugin state
   - Events trigger UI updates
   - UI is always consistent

2. **Action Handlers**
   ```typescript
   function addTodo(text: string) {
     messageBus.sendCommand('AddTodo', { text });
   }
   ```
   - Simple command wrappers
   - No direct state manipulation
   - Clear separation of concerns

## Limitations and Considerations

1. **Persistence**
   - This example uses in-memory storage
   - For persistence, use Figma's `clientStorage` API
   - Consider caching in UI for better performance

   > **Note**: All data passed through the Message Bus must be JSON-serializable. The Message Bus handles
   > `Map` and `Set` automatically, but other complex types might need special handling. See
   > [Serialization](/?path=/docs/üì¶-message-bus-„Ä∞Ô∏è-üöß-beta-internals--docs#serialization-utilities) for details.

2. **Error States**
   - UI should handle loading states
   - Consider optimistic updates
   - Add retry logic for failed operations

3. **Performance**
   - Large lists might need pagination
   - Consider batching updates
   - Cache data in UI when possible

4. **Event Cleanup**
   - Group related cleanups together
   - Clean up on component unmount
   - See [Internals](/?path=/docs/üì¶-message-bus-„Ä∞Ô∏è-üöß-beta-internals--docs#best-practices) for cleanup patterns

## Next Steps

To enhance this example, you could:
- Add persistence using Figma's storage API
- Implement undo/redo support
- Add bulk operations
- Implement optimistic updates
- Add loading states and error handling UI
  