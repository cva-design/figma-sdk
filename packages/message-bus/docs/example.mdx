import { Meta } from '@storybook/blocks';

<Meta title="Example" />

# Building a Simple Plugin with Message Bus

This example demonstrates a Figma plugin that tracks node changes and provides undo/redo functionality.

## Type Definitions

First, let's define our message types and validation schemas:

~~~typescript
import type { tags } from 'typia';
import typia from 'typia';

// Command and Event types
interface Commands {
  // Track a new change
  TrackChange: {
    nodeId: string & tags.Format<"uuid">;
    property: string & tags.MinLength<1>;
    oldValue: unknown;
    newValue: unknown;
  };

  // Undo/Redo operations
  Undo: void;
  Redo: void;

  // Get current history state
  GetHistoryState: void;
}

interface Events {
  // Notify UI about changes
  HistoryChanged: {
    canUndo: boolean;
    canRedo: boolean;
    /**
     * @minimum 0
     */
    totalChanges: number & tags.Type<"uint32">;
  };

  // Notify about errors
  HistoryError: {
    message: string & tags.MinLength<1>;
    command?: keyof Commands;
  };
}

// Create validation schemas
const validators = {
  trackChange: typia.createValidate<Commands['TrackChange']>(),
  historyChanged: typia.createValidate<Events['HistoryChanged']>(),
  historyError: typia.createValidate<Events['HistoryError']>()
};
~~~

## Plugin Code

Here's the plugin-side implementation:

~~~typescript
// @filename: plugin-code.ts
// Note: This is example code. In a real project, you would import from your installed package
import type { Accepted, Rejected } from '@figma-plugin-sdk/message-bus';
import type { Commands, Events } from './types';
import { validators } from './types';

// For example purposes only
declare function getMessageBus<C, E>(): any;

const messageBus = getMessageBus<Commands, Events>();

// Simple history implementation
class History {
  private changes: Array<Commands['TrackChange']> = [];
  private currentIndex = -1;

  track(change: Commands['TrackChange']) {
    // Remove any future changes if we're not at the end
    this.changes.splice(this.currentIndex + 1);
    this.changes.push(change);
    this.currentIndex = this.changes.length - 1;
    this.publishState();
  }

  undo(): boolean {
    if (!this.canUndo()) return false;
    const change = this.changes[this.currentIndex];
    this.applyChange(change, true);
    this.currentIndex--;
    this.publishState();
    return true;
  }

  redo(): boolean {
    if (!this.canRedo()) return false;
    const change = this.changes[this.currentIndex + 1];
    this.applyChange(change, false);
    this.currentIndex++;
    this.publishState();
    return true;
  }

  private applyChange(change: Commands['TrackChange'], isUndo: boolean) {
    const node = figma.getNodeById(change.nodeId);
    if (!node) return;

    const value = isUndo ? change.oldValue : change.newValue;
    (node as any)[change.property] = value;
  }

  private canUndo() {
    return this.currentIndex >= 0;
  }

  private canRedo() {
    return this.currentIndex < this.changes.length - 1;
  }

  private publishState() {
    const state = {
      canUndo: this.canUndo(),
      canRedo: this.canRedo(),
      totalChanges: this.changes.length
    };

    if (validators.historyChanged(state)) {
      messageBus.publishEvent('HistoryChanged', state);
    }
  }
}

const history = new History();

// Command Handlers
messageBus.handleCommand('TrackChange', async (data) => {
  try {
    if (!validators.trackChange(data)) {
      return {
        status: 'rejected',
        message: 'Invalid change data',
        errors: [{ field: 'data', message: 'Failed schema validation' }]
      } satisfies Rejected;
    }

    history.track(data);
    return { status: 'accepted' } satisfies Accepted;
  } catch (error) {
    return {
      status: 'rejected',
      message: error.message,
      errors: [{ field: 'unknown', message: error.message }]
    } satisfies Rejected;
  }
});

messageBus.handleCommand('Undo', async () => {
  try {
    if (!history.undo()) {
      return {
        status: 'rejected',
        message: 'Nothing to undo',
        errors: [{ field: 'state', message: 'History is empty' }]
      } satisfies Rejected;
    }
    return { status: 'accepted' } satisfies Accepted;
  } catch (error) {
    return {
      status: 'rejected',
      message: error.message,
      errors: [{ field: 'unknown', message: error.message }]
    } satisfies Rejected;
  }
});

messageBus.handleCommand('Redo', async () => {
  try {
    if (!history.redo()) {
      return {
        status: 'rejected',
        message: 'Nothing to redo',
        errors: [{ field: 'state', message: 'No future changes' }]
      } satisfies Rejected;
    }
    return { status: 'accepted' } satisfies Accepted;
  } catch (error) {
    return {
      status: 'rejected',
      message: error.message,
      errors: [{ field: 'unknown', message: error.message }]
    } satisfies Rejected;
  }
});

// Listen to Figma's selection changes
figma.on('selectionchange', () => {
  // Track selection changes
  const selection = figma.currentPage.selection;
  if (selection.length === 1) {
    const node = selection[0];
    history.track({
      nodeId: node.id,
      property: 'selection',
      oldValue: null,
      newValue: node.id
    });
  }
});
~~~

## UI Code

Here's the UI implementation:

~~~typescript
// @filename: ui.ts
// Note: This is example code. In a real project, you would import from your installed package
import type { Commands, Events } from './types';

// For example purposes only
declare function getMessageBus<C, E>(): any;

const messageBus = getMessageBus<Commands, Events>();

// UI State
let canUndo = false;
let canRedo = false;

// Event Listeners
messageBus.listenToEvent('HistoryChanged', (state) => {
  if (validators.historyChanged(state)) {
    canUndo = state.canUndo;
    canRedo = state.canRedo;
    updateUI();
  }
});

messageBus.listenToEvent('HistoryError', (error) => {
  if (validators.historyError(error)) {
    console.error('History Error:', error.message);
    const errorEl = document.getElementById('error');
    if (errorEl) errorEl.textContent = error.message;
  }
});

// UI Actions
async function handleUndo() {
  try {
    const result = await messageBus.sendCommand('Undo');
    if (result.status === 'rejected') {
      console.error('Undo failed:', result.errors);
      const errorEl = document.getElementById('error');
      if (errorEl) errorEl.textContent = result.message;
    }
  } catch (error) {
    console.error('Command failed:', error);
  }
}

async function handleRedo() {
  try {
    const result = await messageBus.sendCommand('Redo');
    if (result.status === 'rejected') {
      console.error('Redo failed:', result.errors);
      const errorEl = document.getElementById('error');
      if (errorEl) errorEl.textContent = result.message;
    }
  } catch (error) {
    console.error('Command failed:', error);
  }
}

// UI Rendering
function updateUI() {
  const undoBtn = document.getElementById('undo');
  const redoBtn = document.getElementById('redo');
  
  if (undoBtn) undoBtn.disabled = !canUndo;
  if (redoBtn) redoBtn.disabled = !canRedo;
}

// Initial setup
document.getElementById('undo')?.addEventListener('click', handleUndo);
document.getElementById('redo')?.addEventListener('click', handleRedo);
~~~

## Key Points

1. **Type Safety**
   - All messages are validated with Typia
   - Command responses use proper Accepted/Rejected types
   - Events are validated before publishing

2. **Error Handling**
   - Commands return detailed error information
   - UI shows error messages to users
   - Console logs provide debugging info

3. **Event Cleanup**
   - Event listeners are managed by the Message Bus
   - UI code handles DOM cleanup
   - No manual cleanup needed for Figma events

## Next Steps

- Learn about [Advanced Patterns](/?path=/docs/üì¶-message-bus-„Ä∞Ô∏è-üöß-beta-advanced-patterns--docs)
- See the [Todo App Example](/?path=/docs/üì¶-message-bus-„Ä∞Ô∏è-üöß-beta-todo-app--docs)
- Explore [Internals](/?path=/docs/üì¶-message-bus-„Ä∞Ô∏è-üöß-beta-internals--docs)